<!DOCTYPE html>
<html lang="VN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Fireworks: Giao Th·ª´a 2026 - UET Edition</title>
    <!-- Import Font: Cinzel (Sang tr·ªçng), Montserrat (Hi·ªán ƒë·∫°i), Dancing Script (Vi·∫øt tay) -->
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Dancing+Script:wght@700&family=Montserrat:wght@300;400;600&display=swap" rel="stylesheet">

    <style>
        body {
            margin: 0; overflow: hidden; background-color: #050A14; /* Midnight Blue */
            font-family: 'Montserrat', sans-serif;
            touch-action: none; user-select: none;
        }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }

        /* --- UI LAYER (Glassmorphism Vibe) --- */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10; pointer-events: none;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            /* L·ªõp ph·ªß m·ªù nh·∫π t·∫°o chi·ªÅu s√¢u */
            background: radial-gradient(circle at center, transparent 40%, rgba(5, 10, 20, 0.6) 100%);
        }

        /* --- SCORE BOARD (Minimalist) --- */
        #score-board {
            position: absolute;
            top: 30px;
            right: 40px;
            font-family: 'Montserrat', sans-serif;
            font-weight: 300;
            font-size: 24px;
            color: #F0E68C; /* Champagne Gold */
            padding: 8px 20px;
            background: rgba(255, 255, 255, 0.05); /* Si√™u trong su·ªët */
            backdrop-filter: blur(8px);
            border: 1px solid rgba(240, 230, 140, 0.3);
            border-radius: 30px;
            display: flex;
            align-items: center;
            gap: 12px;
            box-shadow: 0 0 20px rgba(240, 230, 140, 0.1);
            z-index: 20;
            letter-spacing: 1px;
        }
        #score-board::before {
            content: 'üéÅ';
            font-size: 20px;
            filter: grayscale(20%) brightness(1.2);
        }

        /* --- BOSS HEALTH BAR (Responsive) --- */
        #boss-health-bar {
            position: absolute;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            width: 450px; /* Default desktop width */
            max-width: 90%; /* Mobile safe width */
            height: 12px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            display: none;
            z-index: 20;
            overflow: visible;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        #boss-health-bar::before {
            content: '‚ú® QU·∫¢ C·∫¶U NƒÇM M·ªöI ‚ú®';
            position: absolute;
            top: -35px;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Cinzel', serif;
            color: #F0E68C;
            font-size: 16px;
            letter-spacing: 4px;
            text-shadow: 0 0 10px rgba(240, 230, 140, 0.5);
            white-space: nowrap;
        }

        #boss-health-fill {
            width: 100%;
            height: 100%;
            border-radius: 10px;
            background: linear-gradient(90deg, #D8BFD8, #FFB6C1, #F0E68C);
            box-shadow: 0 0 15px rgba(255, 182, 193, 0.6);
            transition: width 0.3s ease-out;
        }

        /* --- START SCREEN (Responsive Text) --- */
        #countdown-display {
            font-family: 'Cinzel', serif;
            font-size: 5vw;
            color: #FFFFF0;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.4);
            text-align: center;
            line-height: 1.4;
            margin-bottom: 40px;
            font-weight: 400;
            padding: 0 20px;
        }
        #countdown-display span {
            font-family: 'Dancing Script', cursive;
            font-size: 3.5vw;
            color: #F0E68C;
            display: block;
            margin-top: 10px;
        }

        #start-btn {
            pointer-events: auto;
            padding: 15px 50px;
            font-size: 18px;
            font-family: 'Montserrat', sans-serif;
            font-weight: 300;
            color: #F0E68C;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid #F0E68C;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 0 20px rgba(240, 230, 140, 0.1);
            display: none;
            text-transform: uppercase;
            letter-spacing: 3px;
            transition: all 0.4s ease;
            backdrop-filter: blur(4px);
        }
        #start-btn:hover {
            background: rgba(240, 230, 140, 0.15);
            box-shadow: 0 0 30px rgba(240, 230, 140, 0.4);
            letter-spacing: 5px;
        }

        /* --- MOBILE OPTIMIZATION --- */
        @media (max-width: 768px) {
            #score-board {
                top: 20px; right: 20px;
                font-size: 18px; /* Nh·ªè h∆°n tr√™n mobile */
                padding: 5px 15px;
            }
            #boss-health-bar {
                top: 85px;
                /* width ƒë√£ c√≥ max-width: 90% lo */
            }
            #boss-health-bar::before {
                font-size: 14px; /* T√™n boss nh·ªè l·∫°i x√≠u */
                letter-spacing: 2px;
            }
            #countdown-display {
                font-size: 32px; /* C·ªë ƒë·ªãnh px ƒë·ªÉ kh√¥ng b·ªã qu√° nh·ªè */
            }
            #countdown-display span {
                font-size: 24px;
            }
            #start-btn {
                padding: 12px 40px;
                font-size: 16px;
                width: 80%; /* N√∫t b·∫•m to d·ªÖ ·∫•n */
            }
        }

        /* --- LOADERS --- */
        #game-loader {
            position: absolute; inset: 0;
            background: #050A14;
            z-index: 200; display: none;
            flex-direction: column; justify-content: center; align-items: center;
        }
        .game-loader-bar {
            width: 300px; height: 2px;
            background: rgba(255,255,255,0.1);
            margin-bottom: 20px;
        }
        #game-loader-fill {
            width: 0%; height: 100%;
            background: #F0E68C;
            box-shadow: 0 0 10px #F0E68C;
            transition: width 0.1s linear;
        }
        #game-loader-text {
            color: #888; font-family: 'Montserrat', sans-serif;
            font-size: 12px; letter-spacing: 3px; text-transform: uppercase;
        }

        #initial-loader {
            position: absolute; inset: 0; background: #050A14; z-index: 300;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: #F0E68C; transition: opacity 1s ease;
            font-family: 'Cinzel', serif; letter-spacing: 2px;
        }
        .spinner {
            border: 2px solid rgba(240, 230, 140, 0.1); border-top: 2px solid #F0E68C;
            border-radius: 50%; width: 40px; height: 40px; animation: spin 1.5s linear infinite; margin-bottom: 20px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        #gesture-hint {
            position: absolute; bottom: 50px; width: 100%; text-align: center;
            color: rgba(255, 255, 255, 0.8);
            font-family: 'Montserrat', sans-serif; font-weight: 300; font-size: 14px;
            letter-spacing: 1px;
            z-index: 11; pointer-events: none; display: none;
            text-shadow: 0 0 10px rgba(255,255,255,0.2);
            padding: 0 10px;
        }

        #webcam-wrapper { position: absolute; opacity: 0; pointer-events: none; }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm"
            }
        }
    </script>
</head>
<body>

<div id="initial-loader">
    <div class="spinner"></div>
    <div>KH·ªûI T·∫†O KH√îNG GIAN...</div>
</div>

<div id="game-loader">
    <div class="game-loader-bar">
        <div id="game-loader-fill"></div>
    </div>
    <div id="game-loader-text">ƒêang chu·∫©n b·ªã ph√°o hoa... 0%</div>
</div>

<div id="canvas-container"></div>
<div id="score-board">0</div>
<div id="boss-health-bar"><div id="boss-health-fill"></div></div>

<div id="ui-layer">
    <div id="countdown-display">KHO·∫¢NH KH·∫ÆC GIAO TH·ª™A<br><span>C√πng CLB Thuy·∫øt tr√¨nh</span></div>
    <button id="start-btn">CH√ÇM NG√íI PH√ÅO HOA</button>
</div>

<div id="gesture-hint"> Ng√≥n tr·ªè ƒë·ªÉ ng·∫Øm ‚Ä¢ Gi·∫≠t tay ƒë·ªÉ b·∫Øn ph√°o hoa ‚Ä¢ ·∫•n v√†o H·ªôp qu√† c≈©ng ƒë∆∞·ª£c nha! </div>
<div id="webcam-wrapper"><video id="webcam" autoplay playsinline></video></div>

<script type="module">
    import * as THREE from 'three';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

    // --- CONFIG ---
    let isModeActive = false;
    let lastFireTime = 0;
    let celebrationCount = 0;
    const FIRE_COOLDOWN = 300;
    const JERK_THRESHOLD = 0.05;
    const CELEBRATION_MESSAGES = [
        "HAPPY NEW YEAR 2026",
        "BELIEVE IN YOUR DREAMS",
        "ƒê·∫¶U T∆Ø HPDE NGON NU√îN",
        "SHINE LIKE A STAR",
        "CAM ON VI DA DEN" ];
    let previousIndexTip = null;
    let score = 0;

    let nextBossThreshold = 10;
    let isBossActive = false;
    let bigBoss = null;
    let celebrationText = null;
    let giftBoxes = [];
    let fireworks = [];
    let stickers = [];

    let lastGiftSpawnTime = 0;
    const GIFT_SPAWN_RATE = 1500;
    const STICKER_ICONS = [
        // --- CH·ª¶ ƒê·ªÄ T·∫æT & TRUY·ªÄN TH·ªêNG ---
        "üß®", "üßß", "üèÆ", "üå∏", "üåº", "üçä", "üçµ", "üêâ",

        // --- TI·ªÜC T√ôNG & QU·∫®Y (PARTY VIBE) ---
        "ü•Ç", "üçª", "üçæ", "üéâ", "üéä", "üéà", "ü•≥", "üòé", "üíÉ", "üï∫", "üéµ", "üé§",

        // --- T√ÄI L·ªòC & MAY M·∫ÆN (RICH KID STYLE) ---
        "üí∞", "üíé", "üèÜ", "ü•á", "üçÄ", "üëë", "üíµ", "üí≥", "üìÄ",

        // --- T√åNH Y√äU & C·∫¢M X√öC ---
        "‚ù§Ô∏è", "üíñ", "ü•∞", "üòç", "üíå", "üåπ", "üíã",

        // --- V≈® TR·ª§ & PH√âP THU·∫¨T (DREAMY) ---
        "‚ú®", "‚≠ê", "üåü", "üöÄ", "üõ∏", "üåô", "‚òÑÔ∏è", "üîÆ",

        // --- BONUS NƒÇM 2026 (NƒÉm Ng·ªç - Con Ng·ª±a) ---
        "üêé", "ü¶Ñ"
    ];
    // Audio
    const bgMusic = new Audio('firework.mp3');
    bgMusic.loop = true; bgMusic.volume = 0.4;
    const fireworkSfx = new Audio('katty.mp3');
    fireworkSfx.volume = 0.6;

    // ThreeJS
    let scene, camera, renderer, composer;
    let cursorMesh;
    let clock = new THREE.Clock();
    const raycaster = new THREE.Raycaster();
    const mouseVector = new THREE.Vector2();

    // AI
    let handLandmarker, video;
    let detecting = false;

    // UI Elements
    const scoreEl = document.getElementById('score-board');
    const bossHpBar = document.getElementById('boss-health-bar');
    const bossHpFill = document.getElementById('boss-health-fill');

    // =============================================================================
    // TEXTURE HELPERS (Elegant Style)
    // =============================================================================
    function createBoxTexture(emoji, isBoss) {
        const canvas = document.createElement('canvas');
        canvas.width = 512; canvas.height = 512;
        const ctx = canvas.getContext('2d');

        // 1. N·ªÄN (GI·∫¢M S√ÅNG - Darker Cream)
        ctx.fillStyle = '#E6D8AD'; // Thay v√¨ #FFFFF0 (Tr·∫Øng qu√°)
        ctx.fillRect(0, 0, 512, 512);

        // 2. VI·ªÄN (V√†ng Kim / Gold)
        ctx.lineWidth = 30;
        ctx.strokeStyle = isBoss ? '#877c45' : '#786a3e'; // Vi·ªÅn t·ªëi h∆°n x√≠u cho qu√† th∆∞·ªùng
        ctx.strokeRect(0, 0, 512, 512);

        // 3. ICON
        ctx.font = '280px serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = '#333';
        ctx.fillText(emoji, 256, 260);

        const tex = new THREE.CanvasTexture(canvas);
        tex.colorSpace = THREE.SRGBColorSpace;
        return tex;
    }

    function createStickerTexture(emoji) {
        const canvas = document.createElement('canvas');
        canvas.width = 256; canvas.height = 256;
        const ctx = canvas.getContext('2d');
        ctx.font = '200px serif';
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.shadowColor = "white";
        ctx.shadowBlur = 10;
        ctx.fillText(emoji, 128, 128);
        return new THREE.CanvasTexture(canvas);
    }

    function createTextTexture(text) {
        const canvas = document.createElement('canvas');
        canvas.width = 2048; canvas.height = 512;
        const ctx = canvas.getContext('2d');

        // D√πng font c√≥ ch√¢n sang tr·ªçng
        ctx.font = 'bold 140px "Times New Roman", serif';
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';

        // Glow nh·∫π
        ctx.shadowColor = "rgba(255, 215, 0, 0.8)";
        ctx.shadowBlur = 20;

        // Gradient V√†ng Kim
        const g = ctx.createLinearGradient(0,0,0,512);
        g.addColorStop(0, "#FFFFF0");
        g.addColorStop(0.5, "#FFD700");
        g.addColorStop(1, "#DAA520");
        ctx.fillStyle = g;

        ctx.fillText(text, 1024, 256);

        ctx.lineWidth = 2;
        ctx.strokeStyle = "rgba(255,255,255,0.5)";
        ctx.strokeText(text, 1024, 256);

        return new THREE.CanvasTexture(canvas);
    }

    // =============================================================================
    // THREE SETUP
    // =============================================================================
    function initThree() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050A14);

        const loader = new THREE.TextureLoader();
        loader.load('https://images.unsplash.com/photo-1534796636912-3b95b3ab5986?q=80&w=2072&auto=format&fit=crop', (tex) => {
            tex.colorSpace = THREE.SRGBColorSpace;
            scene.background = tex;
            scene.backgroundIntensity = 0.15;
        });

        camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.z = 50;

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const renderPass = new RenderPass(scene, camera);

        // --- BLOOM CONFIG (Dreamy) ---
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.4;
        bloomPass.strength = 0.5;
        bloomPass.radius = 0.8;

        composer = new EffectComposer(renderer);
        composer.addPass(renderPass);
        composer.addPass(bloomPass);

        const cursorGeo = new THREE.RingGeometry(0.4, 0.45, 64);
        const cursorMat = new THREE.MeshBasicMaterial({ color: 0xFFD700, transparent: true, opacity: 0, depthTest: false });
        cursorMesh = new THREE.Mesh(cursorGeo, cursorMat);
        cursorMesh.renderOrder = 9999;
        scene.add(cursorMesh);

        window.addEventListener('resize', onResize);
        window.addEventListener('pointerdown', onPointerDown);
    }

    function onResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
    }

    function onPointerDown(e) {
        if (!isModeActive) return;
        mouseVector.x = (e.clientX / window.innerWidth) * 2 - 1;
        mouseVector.y = -(e.clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouseVector, camera);
        const dist = -raycaster.ray.origin.z / raycaster.ray.direction.z;
        if(dist > 0) {
            const pos = new THREE.Vector3();
            raycaster.ray.at(dist, pos);
            launchFirework(pos);
        }
    }

    // =============================================================================
    // CLASSES
    // =============================================================================

    class Sticker {
        constructor(pos) {
            this.isDead = false;
            this.life = 2.5;

            const icon = STICKER_ICONS[Math.floor(Math.random() * STICKER_ICONS.length)];
            const map = createStickerTexture(icon);
            const mat = new THREE.SpriteMaterial({ map: map, transparent: true, opacity: 0.9 });
            this.sprite = new THREE.Sprite(mat);

            this.sprite.position.copy(pos);
            this.sprite.position.x += (Math.random() - 0.5) * 3;
            this.sprite.position.y += (Math.random() - 0.5) * 3;

            this.sprite.scale.set(5, 5, 1);
            scene.add(this.sprite);
        }

        update(dt) {
            this.life -= dt;
            this.sprite.position.y += dt * 2;
            this.sprite.position.x += Math.sin(this.life * 5) * 0.05;

            if (this.life < 1.0) {
                this.sprite.material.opacity = this.life;
            }
            if (this.life <= 0) {
                this.isDead = true;
                scene.remove(this.sprite);
                this.sprite.material.map.dispose();
                this.sprite.material.dispose();
            }
        }
    }

    class GiftBox {
        constructor(pos) {
            this.isDead = false;
            const geo = new THREE.BoxGeometry(4.5, 4.5, 4.5);
            const texture = createBoxTexture("üéÅ", false);

            const mat = new THREE.MeshBasicMaterial({
                map: texture,
                color: 0xcccccc, // GI·∫¢M ƒê·ªò S√ÅNG (X√°m nh·∫°t thay v√¨ Tr·∫Øng tinh)
                toneMapped: false
            });

            this.mesh = new THREE.Mesh(geo, mat);
            this.mesh.position.copy(pos);

            this.rot = { x: Math.random()*0.01, y: Math.random()*0.02 };
            scene.add(this.mesh);
        }
        update() {
            this.mesh.rotation.x += this.rot.x;
            this.mesh.rotation.y += this.rot.y;
            this.mesh.position.y += Math.sin(clock.getElapsedTime() + this.mesh.position.x)*0.01;
        }
        destroy() {
            this.isDead = true;
            scene.remove(this.mesh);
            this.mesh.geometry.dispose(); this.mesh.material.dispose();
            launchFirework(this.mesh.position, true);
            spawnSticker(this.mesh.position);
            score++;
            scoreEl.innerText = score;
        }
    }

    class BigBoss {
        constructor() {
            this.isDead = false;
            this.maxHp = 8;
            this.hp = 8;
            const geo = new THREE.BoxGeometry(12, 12, 12);
            const texture = createBoxTexture("‚ú®", true);

            const mat = new THREE.MeshBasicMaterial({
                map: texture,
                color: 0xeeeeee, // Gi·∫£m nh·∫π ƒë·ªô s√°ng
                toneMapped: false
            });

            this.mesh = new THREE.Mesh(geo, mat);
            // S·ª≠a v·ªã tr√≠ Y t·∫°i ƒë√¢y (s·ªë c√†ng nh·ªè c√†ng th·∫•p)
            // C≈©: 4 -> M·ªõi: 1 (H·∫° th·∫•p xu·ªëng g·∫ßn gi·ªØa m√†n h√¨nh h∆°n)
            this.mesh.position.y = 0.8;
            scene.add(this.mesh);

            bossHpBar.style.display = 'block';
            this.updateUi();
        }
        updateUi() {
            bossHpFill.style.width = (this.hp / this.maxHp * 100) + "%";
        }
        takeDamage() {
            this.hp--;
            this.updateUi();
            this.mesh.material.color.setHex(0xFFB6C1);
            spawnSticker(this.mesh.position);

            setTimeout(() => {
                if(!this.isDead) this.mesh.material.color.setHex(0xeeeeee);
            }, 100);

            if(this.hp <= 0) this.destroy();
        }
        update() {
            this.mesh.rotation.x += 0.005;
            this.mesh.rotation.y += 0.01;
            const s = 1 + Math.sin(clock.getElapsedTime()*3)*0.02;
            this.mesh.scale.set(s,s,s);
        }
        destroy() {
            this.isDead = true;
            scene.remove(this.mesh);
            this.mesh.geometry.dispose(); this.mesh.material.dispose();
            bossHpBar.style.display = 'none';

            for(let i=0; i<8; i++) {
                setTimeout(() => launchFirework(new THREE.Vector3((Math.random()-0.5)*20, (Math.random()-0.5)*15, 0), true), i*150);
            }
            // T·∫°o text ch√∫c m·ª´ng
            let msgText = "";
            if (celebrationCount < CELEBRATION_MESSAGES.length) {
                msgText = CELEBRATION_MESSAGES[celebrationCount];
            } else {
                msgText = "HET GAME ROI =)";
            }
            celebrationCount++;
            celebrationText = new CelebrationText(msgText);
            // Reset tr·∫°ng th√°i boss
            isBossActive = false;
            nextBossThreshold += 20;
        }
    }

    class CelebrationText {
        constructor(msg) {
            this.isDead = false;
            this.life = 6.0;
            const tex = createTextTexture(msg);

            // LOGIC RESPONSIVE CHO 3D TEXT
            // Desktop: R·ªông 40. Mobile: R·ªông nh·ªè h∆°n (24) ƒë·ªÉ l·ªçt m√†n h√¨nh
            const aspect = camera.aspect;
            const width = aspect < 1 ? 24 : 40;
            const height = width / 4; // Gi·ªØ t·ª∑ l·ªá 4:1 c·ªßa texture

            const geo = new THREE.PlaneGeometry(width, height);
            const mat = new THREE.MeshBasicMaterial({
                map: tex, transparent: true, opacity: 0,
                depthTest: false, toneMapped: false, side: THREE.DoubleSide
            });
            this.mesh = new THREE.Mesh(geo, mat);
            this.mesh.position.set(0, 2, 10);
            this.mesh.renderOrder = 999;
            scene.add(this.mesh);
        }
        update(dt) {
            this.life -= dt;
            if(this.life > 5.0) this.mesh.material.opacity = (6.0 - this.life);
            else if(this.life < 1.0) this.mesh.material.opacity = this.life;
            else this.mesh.material.opacity = 1;

            this.mesh.scale.multiplyScalar(1.0005);

            if(this.life <= 0) {
                this.isDead = true;
                scene.remove(this.mesh);
                this.mesh.geometry.dispose(); this.mesh.material.dispose();
                celebrationText = null;
            }
        }
    }

    class Firework {
        constructor(pos) {
            this.isDead = false;
            const count = 180;
            const geo = new THREE.BufferGeometry();
            const positions = new Float32Array(count*3);
            const colors = new Float32Array(count*3);
            this.vels = [];

            const palette = [
                new THREE.Color('#FFB6C1'),
                new THREE.Color('#FFD700'),
                new THREE.Color('#E0FFFF'),
                new THREE.Color('#FFFACD'),
                new THREE.Color('#D8BFD8')
            ];
            const baseColor = palette[Math.floor(Math.random() * palette.length)];

            for(let i=0; i<count; i++) {
                positions[i*3] = pos.x; positions[i*3+1] = pos.y; positions[i*3+2] = pos.z;

                colors[i*3] = baseColor.r * 2.0;
                colors[i*3+1] = baseColor.g * 2.0;
                colors[i*3+2] = baseColor.b * 2.0;

                const speed = 0.5 + Math.random()*3.0;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;

                this.vels.push({
                    x: speed * Math.sin(phi) * Math.cos(theta),
                    y: speed * Math.sin(phi) * Math.sin(theta),
                    z: speed * Math.cos(phi),
                    life: 1.0 + Math.random()*1.0,
                    decay: 0.01 + Math.random()*0.01,
                    flicker: Math.random()
                });
            }
            geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const mat = new THREE.PointsMaterial({
                size: 0.8,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                transparent: true
            });
            this.points = new THREE.Points(geo, mat);
            scene.add(this.points);
        }
        update() {
            const pos = this.points.geometry.attributes.position.array;
            let alive = 0;

            for(let i=0; i<this.vels.length; i++) {
                let v = this.vels[i];
                if(v.life > 0) {
                    pos[i*3] += v.x; pos[i*3+1] += v.y; pos[i*3+2] += v.z;
                    v.y -= 0.02; v.x *= 0.96; v.z *= 0.96;
                    v.life -= v.decay;
                    alive++;
                }
            }
            this.points.geometry.attributes.position.needsUpdate = true;

            if(alive === 0) {
                this.isDead = true;
                scene.remove(this.points);
                this.points.geometry.dispose(); this.points.material.dispose();
            }
        }
    }

    function spawnSticker(pos) {
        stickers.push(new Sticker(pos));
    }

    function launchFirework(pos, silent=false) {
        fireworks.push(new Firework(pos));

        if(isBossActive && bigBoss && !bigBoss.isDead) {
            if(pos.distanceTo(bigBoss.mesh.position) < 15) bigBoss.takeDamage();
        } else {
            giftBoxes.forEach(b => {
                if(!b.isDead && pos.distanceTo(b.mesh.position) < 7) b.destroy();
            });
        }

        if(!silent && fireworkSfx) {
            const s = fireworkSfx.cloneNode(); s.volume = 0.4;
            s.play().catch(()=>{});
        }
    }

    function getSafeSpawnPosition() {
        const minDistance = 12;
        const maxAttempts = 10;

        for(let i=0; i<maxAttempts; i++) {
            const x = (Math.random()-0.5)*60;
            const y = (Math.random()-0.5)*30;
            const candidate = new THREE.Vector3(x, y, 0);

            let safe = true;
            for(let box of giftBoxes) {
                if(candidate.distanceTo(box.mesh.position) < minDistance) {
                    safe = false; break;
                }
            }
            if (isBossActive && bigBoss && !bigBoss.isDead) {
                if(candidate.distanceTo(bigBoss.mesh.position) < 18) {
                    safe = false;
                }
            }
            if(safe) return candidate;
        }
        return null;
    }

    // =============================================================================
    // GAME FLOW
    // =============================================================================

    const startBtn = document.getElementById('start-btn');
    const initLoader = document.getElementById('initial-loader');
    const gameLoader = document.getElementById('game-loader');
    const loaderFill = document.getElementById('game-loader-fill');
    const loaderText = document.getElementById('game-loader-text');
    const countDisplay = document.getElementById('countdown-display');

    async function loadAI() {
        try {
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`, delegate: "GPU" },
                runningMode: "VIDEO", numHands: 1
            });
            initLoader.style.opacity = 0;
            setTimeout(() => initLoader.style.display = 'none', 1000);

            startBtn.style.display = 'block';
        } catch(e) { console.error(e); alert("L·ªói t·∫£i AI: " + e); }
    }

    startBtn.addEventListener('click', () => {
        if(!handLandmarker) return;
        startBtn.style.display = 'none';
        countDisplay.style.display = 'none';
        gameLoader.style.display = 'flex';

        let progress = 0;
        const interval = setInterval(() => {
            progress += 2;
            loaderFill.style.width = progress + "%";
            if(progress < 30) loaderText.innerText = `K·∫æT N·ªêI V·ªÜ TINH... ${Math.floor(progress)}%`;
            else if(progress < 70) loaderText.innerText = `N·∫†P NƒÇNG L∆Ø·ª¢NG PH√ÅO HOA... ${Math.floor(progress)}%`;
            else loaderText.innerText = `CHU·∫®N B·ªä B√ôNG N·ªî... ${Math.floor(progress)}%`;

            if(progress >= 100) {
                clearInterval(interval);
                gameLoader.style.opacity = 0;
                setTimeout(() => {
                    gameLoader.style.display = 'none';
                    startGame();
                }, 500);
            }
        }, 30);
    });

    function startGame() {
        bgMusic.play().catch(()=>{});

        if(navigator.mediaDevices?.getUserMedia) {
            navigator.mediaDevices.getUserMedia({ video: true }).then(stream => {
                video = document.getElementById('webcam');
                video.srcObject = stream;
                video.addEventListener('loadeddata', () => {
                    detecting = true;
                    predict();
                    isModeActive = true;
                    const hint = document.getElementById('gesture-hint');
                    hint.style.display = 'block';
                    setTimeout(() => { hint.style.opacity = 0; }, 8000);
                });
            });
        }
    }

    async function predict() {
        if(!detecting) return;
        if(video.currentTime > 0) {
            const res = handLandmarker.detectForVideo(video, performance.now());
            if(res.landmarks && res.landmarks.length > 0) {
                const lm = res.landmarks[0];
                const index = lm[8];

                const x = (1 - index.x) * 2 - 1;
                const y = -(index.y * 2 - 1);

                mouseVector.set(x, y);
                raycaster.setFromCamera(mouseVector, camera);
                const dist = -raycaster.ray.origin.z / raycaster.ray.direction.z;
                const worldPos = raycaster.ray.at(dist, new THREE.Vector3());

                cursorMesh.position.copy(worldPos);
                cursorMesh.material.opacity = 0.6;

                const wrist = lm[0];
                const dIdx = Math.hypot(lm[8].x-wrist.x, lm[8].y-wrist.y);
                const dMid = Math.hypot(lm[12].x-wrist.x, lm[12].y-wrist.y);

                if(dIdx > 0.1 && dMid < dIdx*0.8) {
                    cursorMesh.material.color.setHex(0xFFD700);
                    if(previousIndexTip) {
                        const vel = Math.hypot(index.x-previousIndexTip.x, index.y-previousIndexTip.y);
                        if(vel > JERK_THRESHOLD && performance.now() - lastFireTime > FIRE_COOLDOWN) {
                            launchFirework(worldPos);
                            lastFireTime = performance.now();
                            cursorMesh.scale.set(2,2,1);
                            cursorMesh.material.color.setHex(0xFFFFFF);
                            setTimeout(()=>cursorMesh.scale.set(1,1,1), 100);
                        }
                    }
                    previousIndexTip = {x: index.x, y: index.y};
                } else {
                    cursorMesh.material.color.setHex(0xF0E68C);
                    previousIndexTip = null;
                }
            } else {
                cursorMesh.material.opacity = 0;
            }
        }
        requestAnimationFrame(predict);
    }

    function animate() {
        requestAnimationFrame(animate);
        const dt = clock.getDelta();
        const now = performance.now();

        if(isModeActive) {
            if(score >= nextBossThreshold && !isBossActive && !celebrationText) {
                isBossActive = true;
                bigBoss = new BigBoss();
            }
            if(!isBossActive && !celebrationText && now - lastGiftSpawnTime > GIFT_SPAWN_RATE) {
                if(giftBoxes.length < 6) {
                    const pos = getSafeSpawnPosition();
                    if(pos) {
                        giftBoxes.push(new GiftBox(pos));
                        lastGiftSpawnTime = now;
                    }
                }
            }
        }

        if(bigBoss && isBossActive) bigBoss.update();
        if(celebrationText) celebrationText.update(dt);

        for(let i=giftBoxes.length-1; i>=0; i--) {
            giftBoxes[i].update();
            if(giftBoxes[i].isDead) giftBoxes.splice(i,1);
        }
        for(let i=fireworks.length-1; i>=0; i--) {
            fireworks[i].update();
            if(fireworks[i].isDead) fireworks.splice(i,1);
        }
        for(let i=stickers.length-1; i>=0; i--) {
            stickers[i].update(dt);
            if(stickers[i].isDead) stickers.splice(i,1);
        }

        composer.render();
    }

    initThree();
    loadAI();
    animate();
</script>
</body>
</html>